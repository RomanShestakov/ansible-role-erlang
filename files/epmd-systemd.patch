From b7c95eabf6017ddb352fb8ce2b3749af108ebf29 Mon Sep 17 00:00:00 2001
From: "Matwey V. Kornilov" <matwey.kornilov@gmail.com>
Date: Tue, 17 Dec 2013 18:16:56 +0400
Subject: [PATCH] Add systemd socket activation for epmd.

Check for systemd libraries and headers in confgiure.
Add -systemd option enabling waiting for sockets from systemd.
---
 erts/configure.in        |  4 ++++
 erts/epmd/src/epmd.c     | 16 ++++++++++++++--
 erts/epmd/src/epmd_int.h |  7 +++++++
 erts/epmd/src/epmd_srv.c | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 71 insertions(+), 2 deletions(-)

diff --git a/erts/configure.in b/erts/configure.in
index bad748d..3ed1238 100644
--- a/erts/configure.in
+++ b/erts/configure.in
@@ -967,6 +967,8 @@ AC_CHECK_LIB(dl, dlopen)
 AC_CHECK_LIB(inet, main)
 AC_CHECK_LIB(util, openpty)
 
+AC_CHECK_LIB(systemd-daemon, sd_listen_fds)
+
 dnl Try to find a thread library.
 dnl
 dnl ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS, ETHR_THR_LIB_BASE and ETHR_DEFS
@@ -1563,6 +1565,8 @@ AC_CHECK_MEMBERS([struct ifreq.ifr_enaddr], [], [],
 	 #endif
 	])
 
+AC_CHECK_HEADERS(systemd/sd-daemon.h)
+
 dnl ----------------------------------------------------------------------
 dnl Check the availability for libdlpi
 dnl ----------------------------------------------------------------------
diff --git a/erts/epmd/src/epmd.c b/erts/epmd/src/epmd.c
index 2d55b37..fc58882 100644
--- a/erts/epmd/src/epmd.c
+++ b/erts/epmd/src/epmd.c
@@ -175,6 +175,9 @@ int main(int argc, char** argv)
     g->nodes.reg = g->nodes.unreg = g->nodes.unreg_tail = NULL;
     g->nodes.unreg_count = 0;
     g->active_conn    = 0;
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+    g->is_systemd     = 0;
+#endif
 
     for (i = 0; i < MAX_LISTEN_SOCKETS; i++)
 	g->listenfd[i] = -1;
@@ -248,8 +251,12 @@ int main(int argc, char** argv)
 	    else
 		usage(g);
 	    epmd_cleanup_exit(g,0);
-	}
-	else
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+	} else if (strcmp(argv[0], "-systemd") == 0) {
+            g->is_systemd = 1;
+            argv++; argc--;
+#endif
+	} else
 	    usage(g);
     }
     dbg_printf(g,1,"epmd running - daemon = %d",g->is_daemon);
@@ -454,6 +461,11 @@ static void usage(EpmdVars *g)
     fprintf(stderr, "        Forcibly unregisters a name with epmd\n");
     fprintf(stderr, "        (only allowed if -relaxed_command_check was given when \n");
     fprintf(stderr, "        epmd was started).\n");
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+    fprintf(stderr, "    -systemd\n");
+    fprintf(stderr, "        Wait for socket from systemd. The option makes sense\n");
+    fprintf(stderr, "        when started from .socket unit.\n");
+#endif
     epmd_cleanup_exit(g,1);
 }
 
diff --git a/erts/epmd/src/epmd_int.h b/erts/epmd/src/epmd_int.h
index 656dbd1..363923e 100644
--- a/erts/epmd/src/epmd_int.h
+++ b/erts/epmd/src/epmd_int.h
@@ -110,6 +110,10 @@
 
 #include <stdarg.h>
 
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+#  include <systemd/sd-daemon.h>
+#endif
+
 /* ************************************************************************ */
 /* Replace some functions by others by making the function name a macro */
 
@@ -321,6 +325,9 @@ typedef struct {
   int listenfd[MAX_LISTEN_SOCKETS];
   char *addresses;
   char **argv;
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+  int is_systemd;
+#endif
 } EpmdVars;
 
 void dbg_printf(EpmdVars*,int,const char*,...);
diff --git a/erts/epmd/src/epmd_srv.c b/erts/epmd/src/epmd_srv.c
index 90df7cc..cb8ca96 100644
--- a/erts/epmd/src/epmd_srv.c
+++ b/erts/epmd/src/epmd_srv.c
@@ -208,6 +208,39 @@ void run(EpmdVars *g)
   node_init(g);
   g->conn = conn_init(g);
 
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+  if (g->is_systemd)
+    {
+      int n;
+      
+      dbg_printf(g,2,"try to obtain sockets from systemd");
+
+      n = sd_listen_fds(0);
+      if (n < 0)
+        {
+          dbg_perror(g,"cannot obtain sockets from systemd");
+          epmd_cleanup_exit(g,1);
+        }
+      else if (n == 0)
+        {
+          dbg_tty_printf(g,0,"systemd provides no sockets");
+          epmd_cleanup_exit(g,1);
+      }
+      else if (n > MAX_LISTEN_SOCKETS)
+      {
+          dbg_tty_printf(g,0,"cannot listen on more than %d IP addresses", MAX_LISTEN_SOCKETS);
+          epmd_cleanup_exit(g,1);
+      } 
+      num_sockets = n;
+      for (i = 0; i < num_sockets; i++)
+        {
+          g->listenfd[i] = listensock[i] = SD_LISTEN_FDS_START + i;
+        }
+    }
+  else
+    {
+#endif
+
   dbg_printf(g,2,"try to initiate listening port %d", g->port);
 
   if (g->addresses != NULL && /* String contains non-separator characters if: */
@@ -272,6 +305,9 @@ void run(EpmdVars *g)
       SET_ADDR(iserv_addr[0],EPMD_ADDR_ANY,sport);
       num_sockets = 1;
     }
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+    }
+#endif
 
 #if !defined(__WIN32__)
   /* We ignore the SIGPIPE signal that is raised when we call write
@@ -289,6 +325,13 @@ void run(EpmdVars *g)
   FD_ZERO(&g->orig_read_mask);
   g->select_fd_top = 0;
 
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H
+  if (g->is_systemd)
+      for (i = 0; i < num_sockets; i++)
+          select_fd_set(g, listensock[i]);
+  else
+    {
+#endif
   for (i = 0; i < num_sockets; i++)
     {
       if ((listensock[i] = socket(FAMILY,SOCK_STREAM,0)) < 0)
@@ -351,6 +394,9 @@ void run(EpmdVars *g)
       }
       select_fd_set(g, listensock[i]);
     }
+#ifdef HAVE_SYSTEMD_SD_DAEMON_H 
+    }
+#endif
 
   dbg_tty_printf(g,2,"entering the main select() loop");
 
